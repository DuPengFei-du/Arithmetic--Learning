/*
题目描述：
牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。
牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,
牛牛想知道他最少可以把这个数组分为几段排序子序列.
如样例所示,
牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,
至少需要划分为2个排序子序列,
所以输出2
*/


/*
输入描述：
输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)
第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。

输出描述：
输出一个整数表示牛牛可以将A最少划分为多少段排序子序列

示例：
输入
6
1 2 3 2 2 1
输出
2
*/


/*
解题思路：
1.本题依次比较整个数组
2.a[i+1]>a[i] ,则进入大于操作，直到遍历到下一个值不大于等于为止count++，然后进行下一位置的判断
3.a[i+1]<a[i],则进入小于操作，直到遍历到下一个值不小于等于为止count++，然后进行下一位置的判断
4.a[i+1] == a[i]不进行操作，++进行下一位置遍历，因为相等既可以属于非递增序列，也可以属于非递减序列。
本题需要注意的点：本题开始比较a[i+1]和a[i],为了避免越界，数组定义为n+1个，同时给a[n]=0;a[n]=0带来的影响，分为三种情况进行讨论:
第一种情况 若到a[n-1] 的最后一组是非递减序列，a[n]=0  在增遍历中执行完i=n-1 for循环使得i=n，不执行for循环结束，因此不影响
第二种情况  若到a[n-1] 的最后一组是非递增序列，a[n]=0  在减遍历中执行完i=n-1 for循环使得i=n，不执行for循环结束，因此不影响
第三种情况  1 2 1 2 1最后一个数是单独的情况，执行完最后一组1 2 i=3 ，for循环i++，此时i=4， <=4 继续执行，此时a[5]为0，a[4]<a[5]进入降处理，count++;i超出范围退出循环。
所以a[n]为0保证了结果的正确性。因此成立
本题中全部相等情况，只执行了i++，未对count进行其他相应处理，所以全部相等情况应进行特殊处理。首先定义equal，每次相等equal++，n个数，共有n-1组相等，因此当equal==n-1表示全部相等的情况，此时应输出1

*/

/*
#include<iostream>
#include<vector>
using namespace std;
int main()
{
	int n;
	cin >> n;
	vector<int> a;
	//注意这里多了一个值，是处理越界的情况比较
	a.resize(n + 1);
	a[n] = 0;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
	}
	int i = 0;
	int count = 0;
	while (i < n)
	{
		//非递减子序列
		if (a[i] < a[i + 1])
		{
			while (i < n && a[i] <= a[i + 1])
				i++;
			count++;
			i++;
		}
		else if(a[i]==a[i+1])
		{
			i++;
		}
		else
		{
			//非递增序列
			while (i < n && a[i] >= a[i + 1])
				i++;
			count++;
			i++;
		}
	}
	cout << count << endl;
	return 0;
}
*/
