/*
请编写一个程序，从键盘上输入n（n 的范围是1～20），求n 的阶乘。
输入第一行为样例数m，接下来m行每行一个整数n，n不超过20。
输出m行表示对应的n的阶乘。
输入 1 3
输出6
提示：注意输出结果可能超32位整型。
*/
/*
理解题目意思很重要！！！！！
题目意思是：输入两个数，第一个数是要计算多少个数的阶乘，第二个是算这个数的阶乘的数
举例：输入 1 3，输出一次：3！；输入2 3，先输出3！，然后再次输入一个数n, 再输出n!
*/

#include<iostream>
using namespace std;
int main()
{
	int m, n;
	cin >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> n;
		long long total = 1;
		for (int j = 1; j <= n; j++)
			total *= j;
		cout << total << endl;
	}
}
#include <iostream>
using namespace std;

int main() {
	int m, n;
	//n 的范围是1～20 先把1-20的阶乘算出来，直接带入即可
	long long* a = new long long[21]; a[1] = 1;
	for (int i = 2; i <= 20; i++) a[i] = a[i - 1] * i;
	while (cin >> m) {
		for (int i = 0; i < m; i++) {
			cin >> n;
			cout << a[n] << endl;
		}
	}
}

/*
请设计一个算法，计算n的阶乘有多少个尾随零。
给定一个int n，请返回n的阶乘的尾零个数。保证n为正整数。
测试样例：
5
返回：1
*/


/*
 * 思路：刚开始做这道题的时候，我是先求出n！再计算有多少个0
 * 这样的复杂度很大，编译不通过，后来在编程之美中看到了思路，思路如下
 *   n!可以质因数分解，由于2*5=10，所以尾零的个数只与2和5有关
 *   但是能被2整除的频率比被5整除的数高的多，所以尾零的个数其实只和5相关，
 *   n！能被多少个5解，就有多少个0，
 *   这事，通过遍历（1到n)只要将能被5整除，就统计+1，最后统计的数，就是尾零的个数
 *
 */

/*
思路：只要出现了一个0，那这个0就不会消失。2*5=0，然后整10会多一个0，于是就没有别的成0了，那简单啊
n如果是18，那就是2*5=1个0,10=1个0,12*15=1个0，看有几组2*5和整10即可
因为有2必有5，有2没5也构不成10，因此看2*5不如看5的数目，而且整10也可以算一个，但整10也就是5*2，也可以看成一组5*2
因此只用看5的数目就可以，有多少个5就是多少个0,但是有点要搞清楚25是两个5,125是3个5，不能都当成1个5来用
当时简单的以为只要是尾数是5的那都是1个5，但是细细想来就可以意识到分解25可以提供两个5，而另一个5去乘4就能得到0,
得到0的数目只跟5有关系，偶数是源源不断的，但5的数目少的可怜，因此只用关注5即可
说是说2*5得到0，实际上是任意一个偶数乘5得到0，因此题目最终分解为n/5+n/25+n/125...直到/5之后等于0
叽里咕噜的说了一大堆，其实都是自己总结自己对这题目的分析，大家挑自己能看懂的部分看就好，写的没什么逻辑性
*/

	public class Factor {
	public int getFactorSuffixZero(int n) {
		int count = 0;
		for (int i = 1; i <= n; i++) {
			int j = i;
			while (j % 5 == 0) {
				count++;
				j /= 5;
			}
		}
		return count;
	}
}